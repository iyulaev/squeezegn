<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Squeezegn by iyulaev</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Squeezegn</h1>
        <p>Tool for compressing genome sequences</p>

        <p class="view"><a href="https://github.com/iyulaev/squeezegn">View the Project on GitHub <small>iyulaev/squeezegn</small></a></p>


        <ul>
          <li><a href="https://github.com/iyulaev/squeezegn/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/iyulaev/squeezegn/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/iyulaev/squeezegn">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>Abstract</h1>

<p>Next-generation DNA sequencing techniques allow for extraction of massive data sets from a given DNA sample, and cloud-based HPC providers have eased access to the large-scale computation resources required to perform analysis on the data. However, due to the high local entropy of the data sets existing compression techniques fail to achieve high compression ratios on the sequence data. Storage and transmission of these datasets has thus become a challenge. We develop an order-insensitive delta-diff compression tool that deflates a genome sequence by generating instructions for recreation via look-ups and substitutions relative to a reference dictionary. The algorithm generates a dictionary from a reference sequence by breaking the sequence into words of a given length and choosing the word list with the most near-repetitions from the entire sequence. The input is similarly broken into words and near-matches are found in the dictionary by sorting the dictionary, locating the lexicographically-nearest word, and searching for the smallest difference count relative to the input string within a given radius. SSE4 bit manipulation instructions are used to speed the calculation of differences between the input and dictionary strings. The output encoding enumerates the dictionary matches plus substitutions that occur due to slight mismatches. For input sequences with a 0.5% density of substitutions relative to the dictionary-generating source, we achieve compression 10x better than ZIP compression. Full source code written in C++11 is provided.</p>

<h1>Description of Project</h1>

<p>Squeezegene is a shared dictionary compression tool for ASCII genome sequences. The goal is to develop a method of compressing gene sequences (especially sequence strings given as output from a sequencing machine) that takes advantage of the prevalence of similar strings within a given genome or sequencing run. Reducing the size of a compressed genome reduces the burden of transferring the genome data, f.ex. when uploading a gene sequencer output file to a cloud computing environment for alignment and analysis.</p>

<p>To this end we try to implement a reasonably efficient compression algorithm that is orthogonal to common LZW compression tools and is geared towards compression of very long sequences comprised of only four discrete symbols. A side effect is to use a shared dictionary, so that multiple sequences can be compressed using a single shared data file (which does not need to be retransmitted when compressing another similar sequence). LZW-based compression should be used on the output compressed file to reduce file size.</p>

<p>A typical use case is to compress several genetic sequences for similar organisms. Due to the similarity in gene sequences between two individuals of related (or the same) species, it is likely that a second sequence can be compressed very efficiently using a recipe-like approach where the sequence can be de-compressed by the receiver based on data from a prior gene sequence. This dramatically reduces the amount of data that must be transmitted when uploading a genome to a server, f.ex. when loading a new sequence run onto a cloud-based HPC provider for secondary processing.</p>

<p>Compressed file size when running squeezegene (and then ZIP compression afterwards) is about 10x smaller than ZIP compression alone, when run on a data set with ~0.5% noise relative to the set used to generate the dictionary. This is not a side-effect of the binary format the squeezegene outputs, simply converting the input stream to binary and then compressing does not yield significant improvement over the ASCII file after compression. Compression performance on a Core 2 processor (running only on a single core) is about 100Kbase/second; this needs to be improved since ZIP compression runs about 10x faster on the same system. Also presently the DictionaryBuilder chokes on input files larger than a few Mbase for systems with ~2GB of memory. Memory use should scale with input file size.</p>

<p>The below graph demonstrates the compression efficiency of squeezegene+ZIP, relative to ZIP, for sequence data with a given amount of substitutions. We see a ~10x improvement over ZIP with up to 0.7% noise. As noise increases the number of dictionary near-matches the compression tool finds decreases and so compression efficiency falls dramatically.</p>

<p><img src="https://raw.github.com/iyulaev/squeezegn/master/density_substitution_perf.png" alt="Performance Results"></p>

<h1>Input Requirements</h1>

<p>Input sequences should be given as ASCII files, with the entire genome on a single "line" (i.e. no line breaks). Valid characters are 'A', 'C', 'G', 'T'. 'N' is not currently valid.</p>

<h2>Example Input</h2>

<p>Example input sequences can be found under the test/Integration directory; the tests.sh and test_big.sh scripts are used to perform dictionary generation, compression, and decompression, and to compare the decompressed output with the original source input. The perl script flatten.pl takes the <a href="http://www.ncbi.nlm.nih.gov/genome">NCBI</a>-sourced genome file and removes line breaks. The scramble.pl script performs a similar function, except can insert substitutions every given number of lines to simulate noise being inserted into the sequence data.</p>

<p>The performance data was derived from the test/Integration/silenenoctifloramitochondrionchromosome1 and 2 sequences. flatten.pl was used to flatten a genome, and then scramble was used to generate a similar sequence with some substitutions included.</p>

<h2>Dictionary File Structure</h2>

<p>The dictionary file is written out in binary. The file is comprised of the following fields, concatenated together:</p>

<p>32-bit int: the number of entries in this dictionary file (n)<br>
n SequenceWords, represented in binary form</p>

<p>The SequenceWords in the dictionary file are sorted lexicographically</p>

<h2>Compressed File Structure</h2>

<p>The following fields are concatenated together to form the compressed file. This is the output of compressor.exe and the input to decompressor.exe.</p>

<p>32-bit int: total size of uncompressed file<br>
32-bit int: the number of exact string insertions instructions in this file<br>
String insertion instructions (32-bit int pairs)<br>
    Each instruction specified a pair of integers: the dictionary string index to insert, and the (uncompressed) file location at which it should be inserted. The output file is initialized to 'A's and then the string insertions are performed<br>
Skip/replace instructions<br>
    These instructions are executed after the string instructions have been finished. We start our pointer at the beginning of the output file and execute the skip/replace instructions on it Each byte in the skip/replace area decodes into one of three possible instructions:<br>
    1. If the byte begins with 1'b0, the subsequent 7 bits of this byte are concatenated with the 8 bits of the next byte to form a 15-bit unsigned integer. This indicates how many characters we should skip ahead<br>
    2. If the byte begins with 2'b10, the lower-most two bits of this byte should be decoded into a single character and written into the current position.<br>
    3. If the byte begins with 2'b11, the lower-most 6 bits of this byte should be decoded into a sequence of three characters (lsb -&gt; 3rd character) and written into the current position as well as the two subsequent positions.  </p>

<h1>Program Components</h1>

<p>There are three components to squeezegene:</p>

<h2>DictionaryBuilder</h2>

<p>Used to build a dictionary for the compressor and decompressor tools. Must be run with three arguments:   </p>

<p>(1) The short read file (ASCII, no line breaks) for the genome from which to generate a dictionary<br>
(2) The name of the output (binary) dictionary file; will be overwritten<br>
(3) (optional) dictionary size to use. For benchmarking on a 1Mbase file a 10K dictionary size works well.  </p>

<p>DictionaryBuilder will output a binary file with the dictionary strings stored in it. This file is used by the downstream tools to compress and decompress ASCII gene sequences.  </p>

<h2>Compressor</h2>

<p>Compressor uses a dictionary file (generated by DictionaryBuilder) and an ASCII genome file to create a compressed genome file. The command-line arguments that compressor takes are:  </p>

<p>(1) Dictionary file to use.<br>
(2) Genome string to compress.<br>
(3) Output file name.  </p>

<h2>Decompressor</h2>

<p>Decompressor takes a dictionary file and an binary compressed genome file to re-create the original ASCII genome. Takes just two arguments:  </p>

<p>(1) Dictionary file to use.<br>
(2) Genome file to decompress.  </p>

<h1>TESTS</h1>

<p>A rudimentary regression test suite has been written for squeezegene. Each component can be tested independently. The procedure for testing the components is given in the README.md file.</p>

<h1>License</h1>

<p>All code copyright Ivan Yulaev, 2012. (<a href="mailto:ivan@yulaev.com">ivan@yulaev.com</a>)
Squeezegene is distributed under GNU GPL. License text can be found in README.md.</p>

<h1>About the Author</h1>

<p>Ivan is a hardware engineer specializing in circuit-board level digital design. For more information about me see <a href="http://www.linkedin.com/pub/ivan-yulaev/33/163/742/">my LinkedIn profile</a>.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/iyulaev">iyulaev</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>